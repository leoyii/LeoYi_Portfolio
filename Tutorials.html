<!DOCTYPE html>
<head>
    <meta charset="utf-8"> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leo Yi's Portfolio | Tutorials</title>

    <link rel="stylesheet" href="css/Tutorials.css">
    <script src="js/Tutorials.js"></script>

</head>
<body>
    <button onclick="topFunction()" id="myBtn" title="Go to top">&#8593;</button>
    <div class="navbar">
        <a href="index.html">Home</a>
        <a href="Tutorials.html">Tutorials</a>
        <a href="Projects.html">Projects</a>
        <a href="Bibliography.html">Bibliography</a>
        <img src="img/logo.png" alt="Logo Image" class="logo">
    </div>
    <br>
    <div id="mySidenav" class="sidenav">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
        <a href="#section1">OOP &nbsp;</a>
        <a href="#section2">Arrays &nbsp;</a>
        <a href="#section3">Arraylists &nbsp;</a>
        <a href="#section4">Searching and <br> Sorting &nbsp;</a>
        <a href="#section5">Recursion</a>
    </div>
    <div id="main">
        <br>
        <a id="section1"></a>
        <span style="font-size:30px;cursor:pointer;background-color:rgb(70,70,70);position:fixed;border-radius:15px;width:130px;height:45px;color:white;padding-left:5px;" onclick="openNav()">&#9776; Menu</span>
        <h1>Object Oriented Programming (OOP)</h1>
        <hr>
    <h4>What is OOP?</h4>
        <p>
            Object Oriented programming, also known as OOP, is a way to simulate real-life situations through software.
            Rather than functions and logic involved in a typical program, OOP is a way to use coding to design data using objects.
        </p>
        <p>
            Objects are instances of classes. An object is a specific entity made from a class that can be manipulated. Each object has behaviours defined by the class that created it.
            In order to create an object, a class is needed.
            A Class is an implementation/blueprint for creating objects with the same behaviour and defined attributes.
            Every instance of a class is assigned to an identifier variable. You will use that identifier to access the attributes and behaviors of the object.
            Attributes and behaviors of the object refer to the instance variables and methods respectively.
            Every single object has their own attributes and behaviors as per the class that it has instantiated.
        </p>
        <p>Here is an example of how you would create an object of the Person class: </p>
        <pre>
        Person p1 = new Person("Bob");
        </pre>
        <p>In this example, p1 is an object created from the Person class and has taken parameter of "Bob" which is the name of the person (attribute of the object).</p>

    <h4>Encapsulation</h4>
    <p>Encapsulation is when the variables and methods are integrated as a single unit and making it so other classes cannot access them, and only the methods of the original class can.
        These are the two modifiers used for Encapsulation: </p>
        <p><b>public:</b> A public variable or method can be accessed and modified by any and all classes in the program.</p>
        <p><b>private:</b> A private variable can only be accessed within the same class it is declared in and cannot be accessed or modified by other classes.</p>

    <h4>Inheritance</h4>

    <p>Inheritance is when you create a subclass that extends the super class. 
        A subclass inherits all the properties and methods from a main class, saving you the time of having to rewrite code.</p>
    <img src="img/inheritance.png">
    <p>
        In the hierarchy chart above, Shape is the main class that is inherited from. 
        It has subclasses: triangle, right triangle and quadrilateral, rectangle, square respectively. 
        The arrows symbolizing the inhertiance from the parent classes. 
        You can see that triangle inherits from shape and right triangle inherits from triangle. 
        However, quadrilateral, rectangle, and square are separate from triangle and right triangle. 
        This means that they cannot inherit or access each others properties.
    </p>
    <p>The <b>super</b> keyword is used to refer to the superclass within a subclass.
        It is used to access the superclass's constructor, methods, and/or attributes.</p>
    <p>The <b>this</b> keyword refers to the current instance of a class. 
        It is used within a class to refer to its own instance variables or methods as opposed to the ones inherited.</p>
    <p>Here is a simplified coded version of the inheritance chart above: </p>
    <pre>
    public class Shape {    //Shape class
        private String shape;   //variable
        public Shape(String name) { //constructor
            shape = name;
        }
        public void getShape(){ //getShape method
            System.out.println("This is a " + shape);
        }
    }

    public class Triangle extends Shape {   //Triangle subclass inherits from Shape superclass
        private int base;   //variables
        private int height;
        public Triangle(String name, int b, int h) {    //constructor
            super(name);    //super
            base = b;
            height = h;
        }
    }

    public class Driver {   //Driver class
        public static void main(String[] args) {    //main method
            Shape s = new Shape("Circle");  //objects
            Triangle t = new Triangle("Equilateral Triangle", 3, 6);
            s.getShape();   //methods
            t.getShape();
        }
    }
    </pre>
    <p>In this code, we can see that super(name) is called in the triangle subclass. 
        We can also see that there is no method in the Triangle class.
        However, when t.getShape() is ran, "Equilateral Triangle" is printed because the getShape() method is inherited from the Shape superclass.</p>

    <h4>Method Overriding and Overloading</h4>
        <p><b>Method Overriding</b> is when you create a method in the subclass that is the same as the parent class and modify it to be used for the subclass.</p>
        <p><b>Method Overloading</b> is the process of creating multiple methods with the same name in the same class, but different parameters.</p>

    <h4>Polymorphism</h4>
        <p>
        Polymorphism adds on to inheritance, in that it uses the inherited methods to perform certain tasks.
        More specifically, it is the act of executing an overidden non-static method from a class at runtime based on the actual object type.
        </p>
        <p>A Method is polymorphic when its overridden in at least one subclass.</p>

        When object of a super class is set to reference object of a sub class, calling overridden methods will refer to those in the subclass.
        However, to call a method that’s exclusively in the subclass, you have to downcast the object: 
        <pre>
        ((subclass) obj).getMethod();
        </pre>
        Otherwise, a compile error will occur.
        <p>At compile-time, methods in or inherited by declared type (left of equal sign type) determine correctness of non-static method call.</p>
        <p>At run-time, the method is executed from class of the actual type (right of equal sign) for a non-static method call.</p>

        <p>Here is some sample code that including polymorphism: </p>
        <pre>
        //Animal Super Class
        public class Animal {
            public void animalSound() {
                System.out.println("The animal makes a sound.");
            }
        }
        //Cat Sub Class which extends Animal
        public class Cat extends Animal {
            public void animalSound() {
                System.out.println("The cat goes meow.");
            }
        }
        //Dog Sub Class which extends Animal
        public class Dog extends Animal {
            public void animalSound() {
                System.out.println("The dog goes woof.");
            }
            public void animalSound2() {
                System.out.println("The dog barks.");
            }
        }
        //Driver Class
        public class Driver {
            public static void main(String[] args) {
                Animal myAnimal = new Animal();  // Create a Animal object
                Animal myCat = new Cat();  // Create a Pig object
                Animal myDog = new Dog();  // Create a Dog object
                myAnimal.animalSound();
                myCat.animalSound();
                myDog.animalSound();
                ((Dog) myDog).animalSound2();
            }
        }
        </pre>
        <p>
        The above code has three classes and a driver class.
        The Animal class is the super class, and the Cat and Dog classes are sub classes extend/inherit from the Animal super class.
        </p>
        <p>
            When myAnimal.animalSound(); is ran, "The animal makes a sound." is printed. 
            When myCat.animalSound(); is ran, "The cat goes meow." is printed.
            When myDog.animalSound(); is ran, "The dog goes woof." is printed.
            When ((Dog) myDog).animalSound2(); is ran, "The dog barks."
            If you run myDog.animalSound2(); without downcasting, the code would not compile because the Animal type cannot access the animalSound2 method in the Dog sub class.
        </p>

    <h4>Abstraction</h4>
        <p>Abstraction is the use of abstract classes and interfaces.
            Abstract classes cannot be instantiated and serve as a blueprint for derived classes. 
            An abstract class allows you to create functionality that subclasses can implement or override. 
            An interface only allows you to define functionality, but subclasses cannot implement it.
            They require a specific set of methods that the implementing classes must provide.
        </p>

        <h1 id="section2">Arrays</h1>
        <hr>
    <h4>Array Creation and Accessing Arrays</h4>
        <p>When array is created with <b>new</b> keyword, elements within the array are initialized to: 0 for an array of integers, 0.0 for an array of doubles, false for an array of booleans, and null for elements of reference type.</p>
        <p>This is an example of how to declare an array: </p>
            <pre>
            DataType[] arrayName = new DataType[n]; //n is the length of the array
            //declaring an array of intergers with length 10
            int[] arr = new int[10];
            </pre>
        <p>In this array of integers, there are 10 elements and elements are all initialized as 0.</p>
        <p>You can then add values to the array using a for loop such as this:</p>
            <pre>
            for (int i = 0; i &lt; arr.length; i++) {
                arr[i] = i;
            }
            </pre>
        <p>If you want to initialize values of an array at the time of declaration, simply do this: </p>
            <pre>
            int array[] = { 1, 2, 3, 4, 5 };
            </pre>
        <p>The length of an array is final cannot be changed after the array is created.</p>

    <h4>Traversing Arrays</h4>
        <p>Elements of an array are accessed by: </p>
            <pre>
            array[index];
            </pre>
        <p>You can use the Arrays.length property to get the length of an array.</p>
        <p>An array starts at index 0, then index 1, index 2, and so on. In the int array[] shown above, array[0] would be 1, array[1] would be 2, and so on.</p>
        <p>There are two ways of traverse an array by using for loops.</p>
        <p>Either you use the standard for loop: </p>
            <pre>
            for (int i = 0; i &lt; array.length; i++) {
                System.out.println(array[i])
            }
            </pre>
        <p>Or you use a for-each loop:</p>
            <pre>
            for (int x : array){
                System.out.println(x);
            }
            </pre>
        <p>You can only change the values of an array in a standard for loop. It does not work with the for each loop.</p>
        <p>There is also a way to display an array without using for loops. It is done using the Arrays.toString() method: </p>
            <pre>
            System.out.println(array.toString());
            </pre>
    <h4>2D Arrays</h4>
    <p>A 2D array is very similar to a standard array, where it is also created using the <b>new</b> keyword, and elements within the 2D array are also initialized to the default value unless specified otherwise.</p>
        <p>This is how you declare a 2D array: </p>
            <pre>
            DataType[][] nameOf2DArray = new DataType[rows][columns];
            //declaring a 2D array of integers with 5 rows and 5 columns
            int[][] arr2D = new int[5][5];
            </pre>
        <p>You can also initialize values of a 2D array at the time of declaration like arrays: </p>
            <pre>
                                    ↓ columns
            int[][] arr2D = {{1, 2, 3, 4, 5},   //row index 0
                             {6, 7, 8, 9, 0},   //row index 1
                    rows ->  {1, 3, 4, 8, 5},   //row index 2
                             {7, 3, 2, 5, 1},   //row index 3
                             {4, 2, 5, 8, 9}}   //row index 4
                              0  1  2  3  4
                              //column index
            </pre>
        <p>The number of rows in a 2D array is found with the 2Darray.length property.</p>
        <p>The number of columns in a 2D array is found with the 2Darray[0].length property.</p>

    <h4>Traversing 2D Arrays</h4>
        <p>Elements in a 2D array are accessed by: </p>
            <pre>
            array[row][column];
            </pre>
        <p>There are two orders of traversing a 2D Array, row-major order and column-major order. Similar to arrays, you can traverse 2D arrays using either a nested for loop, or for each loop.</p>
        <p>For row-major order: First you visit each row, then each column.
        <p>The outer loop is for rows, the inner loop is for columns.</p>
        <p>Nested for loop: </p>
            <pre>
            for(int i = 0; i &lt; arr2D.length; i++){
                for(int j = 0; j &lt; arr2D[0].length; j++){
                    System.out.println(arr2D[i][j]);
                }
            }
            </pre>
        <p>For each loop: </p>
            <pre>
            for(String[] row: arr2D){
                for(String element: row){
                    System.out.print(element);
                }
            }
            </pre>
        <p>For column-major order: First you visit each column, then each row.</p>
        <p>The outer loop is for columns, the inner loop is for rows.</p>
        <p>Nested for loop: </p>
            <pre>
            for(int j = 0; j &lt; arr2D[0].length; j++){
                for(int i = 0; i &lt; arr2D.length; i++){
                    System.out.println(arr2D[i][j]);        
                }
            }
            </pre>
        <p id="section3">For each loops are not possible for column-major order.</p>

        <h1>ArrayLists</h1>
        <hr>
    <h4>ArrayList Declaration</h4>
        <p>You declare an ArrayList in this format: </p>
            <pre>
            ArrayList<DataType> variableName = new ArrayList<DataType>();
            </pre>
        <p>If you want to set a length to your ArrayList, you use this format where n is the length of the ArrayList: </p>
            <pre>
            ArrayList<DataType> variableName = new ArrayList<DataType>(n);
            </pre>
        <p>ArrayLists are mutable, meaning they can be changed, including their size (They have dynamic sizes).</p>
        <p>They are not designed for storing primitive data types, more or so they are used for storing reference data types.</p>

    <h4>ArrayList Methods</h4>
        <p>ArrayList is a class that contains methods, which can be used by importing java.util.ArrayList</p>
        <p>Here is a list of ArrayList methods and what they do:</p>
        <p>size() method - returns how many elements are in the ArrayList.</p>
        <p>add(Element obj) - adds an element to the end of the ArrayList.</p>
        <p>add(int index, E obj) - adds an element to an ArrayList at index.</p>
        <p>remove(int index) - removes the element at index.</p>
        <p>set(int index, obj) - sets the element at index.</p>
        <p>get(int index) - returns the element at index.</p>

    <h4>Traversing Arrays</h4>
        <p>To access elements in ArrayList using a for loop, you need to use the get() method.</p>
        <p>Example code of traversing an ArrayList and removing any values in the ArrayList less than 70: </p>
            <pre>
            for(int i = arrayList.size() - 1; i &gt;= 0; i--){
                if(arrayList.get(i) &lt; 70.0){
                    arrayList.remove(i);
                }
            }
            </pre>
        <p id="section4">You cannot update the original ArrayList with a for loop</p>

        <h1>Searching & Sorting</h1>
        <hr>

    <h4>Binary Search</h4>
        <p>Binary search is an efficient algorithm used for finding an element in sorted array/ArrayList. Binary search works only and only if the array is sorted.</p>
        <p>Below is sample code of Binary Search for integer: </p>
        <pre>
        public static int binarySearch(int[] arr, int target, int low, int high) {
            if(low > high) {
                return -1;
            }
            int mid = (low + high)/2;
            while(low &lt;= high ){  
               if (arr[mid] &lt; target){  
                 low = mid + 1;
               }else if (arr[mid] == target){  
                 System.out.println("Element is found at index: " + mid);  
                 break;
               }else{  
                  high = mid - 1;
               }  
               mid = (low + high)/2;  
            }
        }
        </pre>
        <p>First, you find the middle value of the low and high positions. Then you compare the middle value to the target value (The value you are looking for).</p>
        <p>Based on whether the middle value is less or more than the target, the low position will be moved up, or the high position down.</p>
        <p>Once the middle value is equal to the target value, the index of the middle value will be returned.</p>
        <p>Once the low position crosses the high position, the entire array has been searched, but no value was found, so -1 is returned.</p>
    
    <h4>Selection Sort</h4>
        <p>Selection sort is a search-and-swap algorithm, this means that it will search for a value and swap that value.</p>
        <p>In the case of selection sort, it is similar to sequential search, the sort will first traverse the array for the lowest value. 
            Once it finds the lowest value, it will swap its position in the array with the data at index 0.
            Now the first element is sorted and in the correct position.</p>
        <p>This process then repeats for index 1 and so on. The rest of the array will be searched for the lowest value excluding the values already sorted.</p>
        <p>Note that if the lowest value is already in the correct position, it will stay there and nothing is swapped.</p>
        <p>Below is an example implementation of Selection Sort: </p>
        <pre>
        public void selectionSort(int[] arr){
            for (int i = 0; i &lt; arr.length - 1; i++) {
                int pos = i;
                for (int j = i + 1; j &lt; numbers.length; j++) {
                    if (arr[j] &lt; arr[pos]) {
                        pos = j;
                    }
                }
                int temp = arr[i];
                arr[i] = arr[pos];
                arr[pos] = temp;
            }
        }
        </pre>
        <p>In this example, pos is the position/index of the smallest element in the array. 
            The inner for loop checks for the smallest element in the array and assigns its index to pos.
            the element at index pos is then set to be the first value of the array, while the initial first value is assigned to a temp variable and then set at the index pos.</p>

    <h4>Insertion Sort</h4>
        <p>Rather than traversing the entire array like selection sort, insertion sort is a little less intuitive.</p>
        <p>This sort compares the two elements and, depending on the comparison, it inserts the second value "in front" of the first value, moving the first value to the index of the second value. Then it compares the second and third, third and fourth, and so on.</p>
        <p>This process is also then repeated until the entire array is sorted</p>
        <p>Note that here, like selection sort, an already sorted element will remain in its position.</p>
        <p>Here is an example implementation of Insertion Sort: </p>
        <pre>
        public void insertionSort(int[] arr) {
            for (int i = 1; i &lt; arr.length; i++) {
                int temp = arr[i];
                int j = i - 1;
                while (j &gt;= 0 && arr[j] &gt; temp) {
                    arr[j + 1] = arr[j];
                    j--;
                }
                arr[j + 1] = temp;
            }
        }
        </pre>
        <p>In this example, temp is the second value in the array is assigned to temp. 
            If the first value at index j is larger than the second value (temp), then the first value becomes the second value and the second value becomes the first value.
            If the second value is larger than the first value, then nothing changes.</p>
        <h1 id="section5">Recursion</h1>
        <hr>
    <h4>Introduction</h4>
        <p>Recursion is a programming technique where a method invokes itself to solve a problem by breaking it down into smaller, simpler sub problems. 
        All recursive methods contain two components the <b>base case</b> and the <b>recursive case</b>.</p>

        <p>The <b>base case</b> is the condition that specifies when the recursive method is stopped and returns a value.
            It contains the simplest version of the problem that can be solved directly without further recursion.
            The base case ensures that the recursive calls eventually terminate, so that there isn't an infinite loop of recursive calls.
            This is why a base case is required in all recursive methods that way the method can terminate.</p>

        The <b>recursive case</b> repeatedly breaks the main problem into smaller sub problems in order solve the problem.
        This contains the recursion part of the method, as the method recursively calls itself.
        Each recursive call is intended to handle a smaller input, slowly moving to the base case.

        <p>Here is an example of recursive method factorial(), which calculates the factorial of a number.</p>
        <pre>
        public static int factorial(int n) {
            if (n == 0 || n == 1) { //base case
                return 1;
            } else {    // Recursive case
                return n * factorial(n - 1);
            }
          }
        </pre>
        <p>In this method, we can see that in the recursive case, the method calls itself at factorial(n-1). That is what is called a recursive call, when a method calls itself with a modified input.</p>

    <h4>Merge Sort</h4>
        <p>Merge sort is a sorting algorithm that utilizes recursion.</p>
        <p>Merge sort works by splitting the initial array into smaller sized sub ararys.
        
        </p>
    </div>

    <div id="footer">
        <div id="credits">
            Contact at: lyi972007@gmail.com &nbsp;
            © 2023 - Leo Yi
        </div>
        <div id="outerline"><div id="innerline" onclick="click()"></div></div>
    </div>
</body>